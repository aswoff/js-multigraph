Models are created like this:

    var Person = new Model();

Then you can add properties and methods to the model like this:

    Person.hasA("firstName");
    Person.hasA("lastName");
    Person.hasAn("id");
    Person.hasMany("friends");

    Person.attribute("friends").validatesWith(function (friend) {
        return friend instanceof Person;
    });

    Person.respondsTo("isFriendsWith", function (friend) {
        this.friends().add(friend);
    });

If you're comfortable with anonymous functions, you can send a specification
function to the constructor:

    var Person = new Model(function () {
        //'this' is pointing to the model
        this.hasA("firstName");
        this.hasA("lastName");
        this.hasAn("id");
        this.hasMany("friends");

        this.attribute("friends").validatesWith(function (friend) {
            return friend instanceof Person;
        });

        this.respondsTo("isFriendsWith", function (friend) {
            //in a method specification, 'this' points to
            //the calling object, NOT the model
            this.friends().add(friend);
            friend.friends().add(this);
        });
    });

Finally, you can create a person by calling the model as a constructor:

    var p = new Person(),
        s = new Person(),
        j = new Perons();

And manipulate the objects:

    p.firstName("Mark").lastName("Phillips");
    s.firstName("Semmy").lastName("Purewal");
    j.firstName("John").lastName("Frimmel");

    p.isFriendsWith(s);
    s.isFriendsWith(j);
    j.isFriendsWith(p);

If you later change the model, all new objects will be created with the updated
model spec, but old objects will not enjoy the new features:

   Person.hasAn("id").which.validatesWith(function (id) {
       return typeof(id) === "number";
   });

   var a = new Person();
   a.firstName("Angel").lastName("Brown").id(500);  //fine

   p.id(501); //throws an error